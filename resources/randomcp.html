<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Cp</title>
    <link rel="stylesheet" type = "text/css" href="../style.css">
</head>
<body>
    <div id='wrapper'>
        <div id='head'>
            <a id = "name" href="../index.html"><img src="../img/logo.svg" style="width: 50%;" alt="logo"></a>
            <hr>
            <div id='navigator'>
                <a class="navlink" href="../index.html">Home</a>
                <a class="navlink" href="../about.html">Origami</a>
                <a class="navlink" href="../resources.html">Resources</a>
                <a class="navlink" href="../other.html">Other</a>
            </div>
        </div>
        <hr>
        <h1>Random Cp Generator</h1>
        <div>
            <p>Grid size: (recommended 4-16)</p>
            <input type="text" id="gridsize" value="8">
            <br>
            <p>Initial crease density (recommended ~0.1, but much smaller for larger grids)</p><input type="text" id="creasedensity" value = "0.1">
        </div>
        <br>
        <canvas id="square" width="400" height = "400"></canvas>
        <script src="paper-core.js"></script>
        <script type="text/javascript" data-paper-ignore="true">
            paper.setup(document.getElementById("square"))

            /*
            Features to add, prioritized
            - generate with less errors. main problem right now is in the 5 vertex weird case, which causes overlapping creases and shit (2c)
            - fix big/small/big angle rules, and perhaps a more efficient mv assignment
                -try changing the assignment rules--instead of making the vertex be based on the incoming crease,
                have it pick whichever direction it's closest to, and only use the incoming crease in the event of tiebreaker
                -also try having it prioritize radially alternating creases as much as possible
            - add css/make look good (put credits at bottom)
            - show progression, drawing a new crease every few frames or something. toggleable option [update: why is this so annoying]
            - progress update messages, display info like crease count/crease density
            - import .cp seed
            - separate cp filling/mv assignment tools

            - figure out how to sync up with origami simulator--to impress the non folders
            - connect to neural network somehow? neural net finds what seeds become nice cps
            - in the seed: what's the best ratio between lateral and diagonal creases?
            */
            var grid = null
            var density = null
            //var showProgress = null

            var border = new paper.Path.Rectangle(0,0,400,400);
            border.strokeColor = 'black';
            border.strokeWidth = 4;

            vertices = [] 
            creases = []
            class Vertex {
                constructor(x,y){
                    this.x = x
                    this.y = y
                    this.connectedCreases = []
                    this.unsure = false //for vertices with 3 or 5 creases and have multiple options
                }
                addCrease(v2){
                    //Add a crease that connects to other vertex v2
                    //Check to see if v2 already exists or not
                    v2exists = false
                    for(var j = 0; j<vertices.length; j++){
                        if(vertices[j].x == v2.x && vertices[j].y == v2.y){
                            v2 = vertices[j]
                            v2exists = true
                            break
                        }
                    }

                    if(!v2exists){vertices.push(v2)}
                    crease = new Crease(this,v2)
                    creases.push(crease)
                    this.connectedCreases.push(crease)
                    v2.connectedCreases.push(crease)
                }
                getCreasesAsVectors(){
                    //takes the creases connected to this vertex and returns them as a list of vectors with this vertex as origin
                    //useful for flat foldability calculations, finding angles and whatnot
                    this.vectors = this.connectedCreases.map(v => v.vertices[1]==this ? 
                        [v.vertices[0].x-this.x,v.vertices[0].y-this.y]:[v.vertices[1].x-this.x,v.vertices[1].y-this.y])
                }
                getAngles(){
                    this.angles = this.vectors.map(v => Math.atan2(v[1],v[0])) 
                    //Order the creases in the order of their angles, so starting at -0.75pi you go cc around the creases. Vectors will follow
                    //Perhaps it would have been better to add the angle as an attribute of the crease class?
                    this.connectedCreases = this.connectedCreases.sort((a,b)=>this.angles[this.connectedCreases.indexOf(a)]-this.angles[this.connectedCreases.indexOf(b)])
                    this.angles = this.angles.sort(function(a,b){return a-b})
                    //find the biggest angle difference. Everything below that angle +=2pi
                    this.relativeAngles = this.angles.map((element,index) => element-this.angles[(index>0? index-1 : this.angles.length-1)])
                    this.relativeAngles = this.relativeAngles.map(v => v<0 ? v+2*Math.PI : v ) 
                    this.smallAngles = []
                    for(var i =0; i<this.relativeAngles.length; i++){
                        if(this.relativeAngles[i]==Math.PI/4){
                            this.smallAngles.push([this.connectedCreases[i], i>0? this.connectedCreases[i-1]: this.connectedCreases[this.connectedCreases.length-1]])
                        }
                    }
                    //Find all the angles that are 45 degrees (for the big little big lemma) and store them as creases
                    var first = this.relativeAngles.findIndex(v => v==Math.max(...this.relativeAngles))
                    this.angles = this.angles.map((element,index)=> (index<first? element+2*Math.PI : element)).sort(function(a,b){return a-b})
                    //angles is sorted, but relativeAngles is not.
                }
            }
            class Crease {
                constructor(v1,v2){
                    this.vertices = [v1,v2] //this way we can check if a vertex is in this list to see if they intersect
                    this.mv = 'red' //by default, change later
                }
            }
            //generate() will reset everything, then run through steps 1 2 and 3, then display            
            function generate(){
                console.log('===========new generation===========')
                creases = []
                vertices = []
                invalid = []
                grid = parseInt(gridsize.value)
                density = parseFloat(creasedensity.value)
                //showProgress = document.getElementById('progression').checked
                if(density>1 || density<0 || grid<1){
                    alert("Something went wrong. Please remember: \n   The grid size must be an integer greater than or equal to 1 \n   The density must be a decimal between 0 and 1")
                    return
                } else if(density==1){alert('Sorry, there is a bug caused by a density of 1. Try something like 0.9999 instead.');return}
            
                step1()
                step2()
                step3()
                //display() //crease data is global
                // var done = false 
                // var stop_ = 0;
                // while(!done && stop_<50){
                //     step3();
                //     stop_+=1;
                // }
                // console.log(stop_)
            }
            
            //step 1 is to create a seed of a few random creases from which the rest of the cp will be deterministically generated (except mv uses some random)
            function step1(){
                /*
                Generate a seed of random creases from which the rest of the cp will be drawn to accomodate.
                The number of initial creases drawn is based on the density input.
                The creases are stored in the creases list, and the vertices in the vertices list.
                Each vertex will keep track of all the creases attached to it.
                Of all the possible creases, the chance of it being diagonal is n^2/(3n^2-2n) where n is the grid size
                First decide whether the random crease will be diagonal or lateral
                if diagonal, pick 2 random numbers, both from [0,n-1] and those will be the coords of the diagonal
                if lateral, pick random from [1,n-1] to decide line, and [1,n] to decide segment of the line, then [0,1] to decide horizontal or vertical
                if this crease is already added, choose again.
                */
                initialCreaseNumber = Math.floor(density*(3*grid**2-2*grid))
                mainloop: for(var i = 0; i< initialCreaseNumber; i++){
                    if (Math.random()<grid**2/(3*grid**2-2*grid)){
                        //generate a random diagonal
                        a = Math.floor(Math.random()*(grid))
                        b = Math.floor(Math.random()*(grid))
                        if((a+b)%2==0){
                            //creates diagonal with slope of 1
                            v1 = new Vertex(a,b)
                            v2 = new Vertex(a+1,b+1)
                            //crease = new Crease(v1,v2)
                        } else {
                            //creates diagonal with slope of -1
                            v1 = new Vertex(a+1,b)
                            v2 = new Vertex(a,b+1)
                        }
                    } else {
                        //generate a random lateral
                        a = Math.floor(Math.random()*(grid-1)) +1
                        b = Math.floor(Math.random()*(grid)) 
                        if(Math.random()<0.5){
                            //vertical crease
                            v1 = new Vertex(a,b),
                            v2 = new Vertex(a,b+1)
                        } else{
                            //horizontal crease
                            v1 = new Vertex(b,a),
                            v2 = new Vertex(b+1,a)
                        }
                    }
                    //now that the vertices of this new crease are set, see if these vertices exist or need to be added
                    v1exists = false
                    v2exists = false
                    for(i = 0; i<vertices.length; i++){
                        if(vertices[i].x == v1.x && vertices[i].y == v1.y){
                            v1 = vertices[i]
                            v1exists = true
                        }
                        if(vertices[i].x == v2.x && vertices[i].y == v2.y){
                            v2 = vertices[i]
                            v2exists = true
                        }
                    }
                    if(!v1exists){
                        vertices.push(v1)
                    }
                    if(!v2exists){
                        vertices.push(v2)
                    }
                    crease = new Crease(v1,v2)
                    //check to see if such a crease already exists
                    for(var i = 0; i<creases.length; i++){
                        if(creases[i].vertices.includes(crease.vertices[0]) && creases[i].vertices.includes(crease.vertices[1])){
                            //if this crease has already been done before. Also, if the crease already exists, then the vertices should already exist
                            i = i-1;
                            continue mainloop
                        }
                    }
                    creases.push(crease)
                    crease.vertices[0].connectedCreases.push(crease)
                    crease.vertices[1].connectedCreases.push(crease)
                }
            }
            
            //step 2 is to fill in the rest of the creases based on the seed, to satisfy angle flat foldability
            function step2(){
                /*
                Fill in creases based on the ones generated in step 1.

                run step 2a until no change
                    run through all vertices
                run step 2b until no change
                    fix one, then run step 2a
                run step 2c until no change

                The first rule (2a): at vertices which diagonals aren't allowed, make sure they are flat foldable (have exactly 2 or 4 lateral creases)
                The second rule (2b): at vertices with an odd number of creases and with an angle >= 180, use flat foldability rules to find the guaranteed last crease
                Repeat the first and second rule until there are no more changes (ie, all vertices are ok, or we need the third rule)
                The third rule (2c): at vertices with 2 or 4 creases but aren't flat foldable: (cases with 6 are easy, just draw the remaining 2)
                */

                length0 = creases.length
                step2a()
                while(creases.length>length0){
                    length0 = creases.length 
                    step2a();
                }
                length0 = creases.length
                step2b()
                while(creases.length>length0){
                    invalids = findInvalids(vertices)
                    if(invalids.length==0){
                        return
                    }
                    length0 = creases.length
                    step2b(); //within the step2b is to run 2a to check for the consequences of adding the crease
                }
                length0 = creases.length
                step2c()
                while(creases.length>length0){
                    invalids = findInvalids(vertices)
                    if(invalids.length==0){
                        return
                    }
                    length0 = creases.length
                    step2c(); //within step2c is to run 2b, which will run through 2a
                }
                // length0 = creases.length
                // step2a()
                // step2b() //step 2a will be mixed into step 2b
                // lengthf = creases.length
                
                // if(length0<lengthf){
                //     //If something changed, go back to step 2a to try to fix more stuff
                //     step2()
                // } else if (length0 == lengthf){
                //     //If there was no change, it's time to move on 
                //     //do step 2a and 2b until you can't anymore
                //     return
                //     //I don't think this block is necessary
                // }
                // invalids = findInvalids(vertices)
                // brake = 0 //for stopping infinite loops
                // while(invalids.length != 0 && brake < 30){
                //     step2c()
                //     invalids = findInvalids(vertices)    
                //     brake += 1 
                // }
            }
            function findInvalids(vertices){

                //important: need to look for vertices who have doubled creases, or who have creases not at 45 degree angles.
                //don't necessarily delete them (yet) but need to quarantine them or something, maybe freeze the program and display

                invalids = []
                loop: for(i=0;i<vertices.length;i++){
                    for (var j = 0; j<vertices[i].connectedCreases.length; j++){
                        // if(Math.abs(vertices[i].vectors[j][0]>1) || Math.abs(vertices[i].vectors[j][1]>1)){
                        //     console.log('weird angle found')
                        //     console.table(vertices[i])
                        // }
                        // for (var k = j+1; k<vertices[i].connectedCreases.length; k++){
                        //     if(vertices[i].vectors[j][0]==vertices[i].vectors[k][0] && vertices[i].vectors[j][1]==vertices[i].vectors[k][1]){
                        //         console.log("overlap found")
                        //         console.table(vertices[i])
                        //         break
                        //     }   
                        // }
                    }

                    vertices[i].getCreasesAsVectors()
                    vertices[i].getAngles()
                    if(
                        ![vertices[i].x,vertices[i].y].includes(0) && //if it's not on the edge,
                        ![vertices[i].x,vertices[i].y].includes(grid)&&
                            (vertices[i].connectedCreases.length%2==1 || //and there's either an odd number of creases,
                            //Math.abs(vertices[i].angles.map((element,index) => {return element*(index%2 *2 -1)}).reduce((acc,cur)=> acc+cur))!=Math.PI)
                            //or the sum of every other angle is not 180,
                            Math.abs(vertices[i].relativeAngles.map((element,index) => (index%2)*element).reduce((acc,cur)=> acc+cur))!=Math.PI)    
                        ){
                        invalids.push(vertices[i])
                        continue loop
                    }
                }
                return invalids
            }
            function step2a(){
                for(var i = 0; i<vertices.length;i++){
                    if((vertices[i].x + vertices[i].y)%2==1 && vertices[i].connectedCreases.length!=4 && ![vertices[i].x,vertices[i].y].includes(0) && ![vertices[i].x,vertices[i].y].includes(grid)){
                        //If the vertex is on a spot with no diagonals (ie, x + y is odd), has 1, 2, or 3 creases, and is not on the border
                        vertices[i].getCreasesAsVectors()
                        if(vertices[i].vectors.length==1){
                            //If there is only one crease on this vertex, add a crease in the opposite direction
                            v2 = new Vertex(vertices[i].x-vertices[i].vectors[0][0],vertices[i].y-vertices[i].vectors[0][1])
                            //Check if this new vertex on the other side exists or not already, then add the crease
                            v2exists = false
                            vertices[i].addCrease(v2)
                            continue
                        }
                        if(vertices[i].vectors.length==2 && !(vertices[i].vectors[0][0]==-1*vertices[i].vectors[1][0] && vertices[i].vectors[0][1]==-1*vertices[i].vectors[1][1])){
                            //If there are two vectors on this vertex, and they aren't in a line already, add creases in the remaining 2 directions
                            v1 = new Vertex(vertices[i].x-vertices[i].vectors[0][0],vertices[i].y-vertices[i].vectors[0][1])
                            v2 = new Vertex(vertices[i].x-vertices[i].vectors[1][0],vertices[i].y-vertices[i].vectors[1][1])
                            vertices[i].addCrease(v1);
                            vertices[i].addCrease(v2);
                            continue
                        }
                        if(vertices[i].vectors.length==3){
                            //if there are 3 vectors on this vertex, add a crease in the remaining direction
                            //The remaining direction will be in the opposite direction of the sum of the vectors
                            v2 = new Vertex(vertices[i].x-vertices[i].vectors.map(v => v[0]).reduce((acc,cur) => acc+cur),
                                            vertices[i].y-vertices[i].vectors.map(v => v[1]).reduce((acc,cur) => acc+cur))
                            //Check if this new vertex on the other side exists or not already, then add the crease
                            vertices[i].addCrease(v2)
                            continue
                        }
                    }
                }
            }
            function step2b(){
                for(var i = 0; i<vertices.length;i++){
                    //Now find if there's any angle that is greater than or equal to 180.
                    //if there's 7 creases on the vertex, it will be the last angle to make it all 8
                    //if there are 6 creases on the vertex and it isn't currently flat foldable (number of laterals==3), add the remaining 2
                    //If there's 5 creases on the vertex and an angle = 180, it will bisect the 180 angle
                    //If there's 3 creases on the vertex and an angle >= 180, it will be based on the position of the smaller angles
                    //If there's 1 crease on the vertex: extend it
                    //We start with the 7 vertex bc those are guaranteed, then go down the line. the 1 vertex might get added new stuff
                    //Other stuff like the 3 and 5 vertices might be guaranteed, but if another vertex adds something to it, then it could change
                    //step2a();
                    if([vertices[i].x,vertices[i].y].includes(0)||[vertices[i].x,vertices[i].y].includes(grid)){
                        //If it's on the edge, ignore
                        continue
                    }
                    if(vertices[i].connectedCreases.length==7){
                        //when there are 7 creases, the 8th will be opposite the direction of the sum of the 7 vectors
                        vertices[i].getCreasesAsVectors();
                        v2 = new Vertex(vertices[i].x-vertices[i].vectors.map(v => v[0]).reduce((acc,cur) => acc+cur),
                                        vertices[i].y-vertices[i].vectors.map(v => v[1]).reduce((acc,cur) => acc+cur))
                        vertices[i].addCrease(v2)
                        continue
                    }
                    step2a();
                    if(vertices[i].connectedCreases.length==5){
                        //There are 5 unique cases, 4 of them have only one possible crease, and the other has 3
                        //In the future, perhaps it would be good to pick out that case and decide better, rn it's a bit random which it will choose
                        vertices[i].getCreasesAsVectors();
                        vertices[i].getAngles();
                        if(vertices[i].vectors.map(v=>v[0]).reduce((acc,cur)=>acc+cur)==0 && 
                            vertices[i].vectors.map(v=>v[1]).reduce((acc,cur)=>acc+cur)==0){
                            //there is an annoying case that doesn't fit the normal rule, due to negative angles and other complications
                            //this case happens to be the only case for a 5 vertex whose sum of the vectors is 0
                            console.log("found a weird 5 at", vertices[i].x, vertices[i].y)
                            //the missing crease will be the 4th diagonal
                            diagonal_vectors = [[1,1],[1,-1],[-1,-1],[-1,1]]
                            for(var j = 0; j<4; j++){
                                if (!vertices[i].vectors.includes(diagonal_vectors[j])){
                                    v2 = new Vertex(vertices[i].x+diagonal_vectors[j][0],vertices[i].y+diagonal_vectors[j][1])
                                    break
                                }
                            }
                            vertices[i].addCrease(v2)
                            continue
                        } else {
                            //if not that case, then the last angle goes opposite the direction of the sum of the vectors
                            newAngle = vertices[i].angles[0]-vertices[i].angles[1]+vertices[i].angles[2]-vertices[i].angles[3]+vertices[i].angles[4]-Math.PI
                            if (vertices[i].angles.includes(newAngle)){
                                console.log('5 overlap avoided',vertices[i].x,vertices[i].y,vertices[i].vectors)
                                continue
                            } else {console.log('normal 5 solved', vertices[i].x,vertices[i].y)}

                            v2 = new Vertex(vertices[i].x + (Math.abs(Math.cos(newAngle))>0.01? Math.cos(newAngle)/Math.abs(Math.cos(newAngle)):0),
                                            vertices[i].y + (Math.abs(Math.sin(newAngle))>0.01? Math.sin(newAngle)/Math.abs(Math.sin(newAngle)):0))
                                            //find the position based on the angle, but .ceil rounds up on negatives, and also watch out for div by 0
                            //v2 = new Vertex(vertices[i].vectors.map(v=>v[0]).reduce((acc,cur)=>acc+cur),vertices[i].vectors.map(v=>v[1]).reduce((acc,cur)=>acc+cur))
                            vertices[i].addCrease(v2)
                            continue
                        }
                        

                    }
                    step2a();
                    if(vertices[i].connectedCreases.length==3){
                        //There are 5 unique cases, 4 of them have only one possible crease, and the other has 3
                        //In the future, perhaps it would be good to pick out that case and decide better, rn it's a bit random which it will choose
                        vertices[i].getCreasesAsVectors();
                        vertices[i].getAngles();
                        newAngle = vertices[i].angles[0]+vertices[i].angles[2]-vertices[i].angles[1]-Math.PI
                        if (vertices[i].angles.includes(newAngle)){
                            console.log('3 overlap avoided',vertices[i].x,vertices[i].y,vertices[i].vectors)
                            continue
                        }

                        v2 = new Vertex(vertices[i].x + (Math.abs(Math.cos(newAngle))>0.01? Math.cos(newAngle)/Math.abs(Math.cos(newAngle)):0),
                                        vertices[i].y + (Math.abs(Math.sin(newAngle))>0.01? Math.sin(newAngle)/Math.abs(Math.sin(newAngle)):0))
                                        //find the position based on the angle, but .ceil rounds up on negatives, and also watch out for div by 0
                        vertices[i].addCrease(v2)
                        continue
                    }
                    step2a();
                    if(vertices[i].connectedCreases.length==1){
                        //If there is only one crease on this vertex, add a crease in the opposite direction
                        vertices[i].getCreasesAsVectors();
                        v2 = new Vertex(vertices[i].x-vertices[i].vectors[0][0],vertices[i].y-vertices[i].vectors[0][1])
                        vertices[i].addCrease(v2)
                        continue
                    }
                    step2a();
                }
                //note: can use list inequalities to find the counterclockwise order of angles
            }
            function step2c(){
                //solve ONE vertex with 2 or 4 creases but aren't flat foldable yet. (vertices with 6 can be done earlier)
                //after solving the ONE vertex, rerun step 2a and 2b until we need to do 2c again
                //Will need to add two new creases: decide 1 now, and then do step 2b to decide the other
                //To decide now, first look at available directions. If there are any adjacent vertices who are also invalid or are on the edge, choose it.
                //If not, then pick any random direction, then run step 2b.
                //note: this one can use invalids instead of vertices since step2() will check for invalids before running step2c()
                console.log('running step 2c', brake)
                loop: for(var i = 0; i< vertices.length; i++){
                    vertices[i].getCreasesAsVectors;
                    vertices[i].getAngles;
                    if([vertices[i].x,vertices[i].y].includes(0)||[vertices[i].x,vertices[i].y].includes(grid)){
                        //If it's on the edge, ignore
                        continue
                    }
                    try{
                        if([2,4,6].includes(vertices[i].connectedCreases.length) && 
                            Math.abs(vertices[i].relativeAngles.map((element,index) => (index%2)*element).reduce((acc,cur)=> acc+cur))!=Math.PI
                            ){
                            directions = shuffle([[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1],[0,-1],[1,-1]]) //shuffle this one?
                            for(var j = 0; j< directions.length; j++){
                                //for each direction, see if there's already a crease there, 
                                //then see if that would be on the edge, then see what vertex (if any) is in that direction
                                if(!vertices[i].vectors.map(vector => vector.toString()).includes(directions[j].toString())){
                                    if([0,grid].includes(vertices[i].x+directions[j][0]) || [0,grid].includes(vertices[i].y+directions[j][1])){
                                        //see if the current direction will send a crease to the edge
                                        vertices[i].addCrease(new Vertex(vertices[i].x+directions[j][0],vertices[i].y+directions[j][1]))
                                        break loop
                                    }
                                    if(invalids.find(vertex => vertex.x == vertices[i].x+directions[j][0] && vertex.y==vertices[i].y+directions[j][1])){
                                        //see if the current direction will send a crease to another invalid
                                        vertices[i].addCrease(new Vertex(vertices[i].x+directions[j][0],vertices[i].y+directions[j][1]))
                                        break loop
                                    }
                                }
                            }
                            //If neither of those two conditions were met, then pick any random direction
                            for(var j = 0; j< directions.length; j++){
                                if(!vertices[i].vectors.map(vector => vector.toString()).includes(directions[j].toString())){
                                    vertices[i].addCrease(new Vertex(vertices[i].x+directions[j][0],vertices[i].y+directions[j][1]))
                                    break loop
                                }
                            }
                        }
                    } catch {
                        console.log('Fail', vertices[i])
                    }
                }
                step2a();
                step2b();
            }
            
            //step 3 will find a way to assign mv to the cp, and then display at the end
            function step3(){
                /*
                Start by giving each crease a random mv
                Assign mv recursively
                */
                creases.forEach(crease => {crease.mv = Math.random()>0.6? 'blue': 'red'}) //give each crease a random mv
                mvErrors = findMvErrors(vertices) //find all vertices 
                stop = 0
                while(mvErrors.length>0 && stop<1000){
                    //take the first of the mv errors, attempt to fix it, then recalculate the list and repeat until no mv errors
                    console.log('ran step 3a')
                    step3a(mvErrors[0].connectedCreases[Math.floor(Math.random()*mvErrors[0].connectedCreases.length)],mvErrors[0]) //arbitrary starting crease
                    stop += 1
                    mvErrors = findMvErrors(vertices)
                }
                display()
            }
            function findMvErrors(vertices){
                //The vertex has mv error if:
                //It's not on the edge AND (it fails big angle lemma OR it fails small angle lemma OR it fails m-v=+-2 rule)
                //In general, vertices on the edge can cause self intersection if they fail big little big lemma, but 
                //that gets complicated because it requires counting the edge in the vectors, and doesn't happen in bp. So for now, ignore
                mvErrors = [];
                loop: for(var i = 0; i< vertices.length; i++){
                    vertices[i].getCreasesAsVectors;
                    vertices[i].getAngles;
                    if([vertices[i].x,vertices[i].y].includes(0) || [vertices[i].x,vertices[i].y].includes(grid) ){
                        //if the vertex is on the edge, it's off the hook. Not true for general cp, but for bp it's ok
                        continue loop
                    }
                    if( Math.abs(vertices[i].connectedCreases.filter(crease => crease.mv =='red').length-
                                vertices[i].connectedCreases.filter(crease => crease.mv =='blue').length)!=2){
                        mvErrors.push(vertices[i])
                        //if the vertex has not the right number of mv, it's gg. get in the list
                        continue loop
                    }
                    //To find big little big violations: look for 45 degree angles surrounded by two m or two v
                    //if there is only one small angle and it violates, then the vertex violates
                    //if there are two adjacent small angles, if one violates it's ok, but if both violate then not ok
                    //if there are four adjacent small angles, 1 or two violations are ok. 3 violations are ok if they aren't in a row. 4 is not ok.
                    //if there are 8 small angles, then the vertex is always ok locally (but will quite possibly cause self intersection somewhere)
                    //to simplify, we'll mark it invalid if more than half of the small angles violate.

                    // if(vertices[i].smallAngles.length!=0 && 
                    //     vertices[i].smallAngles.filter(element => element[0].mv==element[1].mv).length/vertices[i].smallAngles.length > 0.5){
                    //     mvErrors.push(vertices[i])
                    //     continue loop
                    // }
                }
                return mvErrors
            }
            function step3a(crease, vertex){
                //Fix a vertex assuming that the input crease is correct
                //Base case: if vertex is already solved (is on the edge OR (m-v=+-2 AND passes simplifed big little big lemma)), return
                //the input crease is assumed to be correct. for example, if input crease is m, then m-v needs to be 2.
                //then, if there are too many m, then randomly choose m to convert to v. But not input crease
                //but if there are too many v, randomly choose v to convert to m.
                //After converting, apply step3a to the other affected vertices.
                if( (Math.abs(vertex.connectedCreases.filter(crease_ => crease_.mv =='red').length-
                            vertex.connectedCreases.filter(crease_ => crease_.mv =='blue').length)==2 && 
                            !vertex.smallAngles.filter(element => element[0].mv==element[1].mv).length/vertex.smallAngles.length > 0.5)||
                    [vertex.x,vertex.y].includes(0) ||
                    [vertex.x,vertex.y].includes(grid) ){
                    return
                } //base case, see if the vertex is done
                //there's an easier way to test for being on the edge
//(vertex.x-0)*(vertex.y-0)*(vertex.x-grid)*(vertex.y-grid)==0

                if(vertex.connectedCreases.length==2){
                    changedCrease = vertex.connectedCreases[vertex.connectedCreases[0]==crease? 1:0]
                    changedCrease.mv = (crease.mv == 'red'? 'red':'blue')
                    step3a(changedCrease, (changedCrease.vertices[0]==vertex? changedCrease.vertices[1] : changedCrease.vertices[0]))
                    return
                } //if this vertex has 2 lines, one is m and one is v, switch the one that wasn't inputted and continue down the line           

                //The desired mv difference is 2 if input crease is m, -2 if input crease is v. This minimizes the changes needed
                //The number of creases to change is (desired - current)/2 because changing v to m will increase v and decrease m
                //If the amount to change is positive, convert V to M.
                //If the amount to change is negative, convert M to V.
                //In either case, make sure the changed crease is not the input crease.
                //After converting, recursively apply this function (3a) to the changed crease and it's vertex on the other side
                //If all goes well, it will keep going around until everybody satisfies the base case (has no mv error)
                mvDifference = vertex.connectedCreases.filter(crease => crease.mv =='red').length- vertex.connectedCreases.filter(crease => crease.mv =='blue').length
                change = (Math.abs(mvDifference)-2)/2 //how far away from 2 or -2 are you?
                vertex.connectedCreases = shuffle(vertex.connectedCreases)
                if (mvDifference == 0){
                    //if the same number of m and v, but more than 2 creases, the input crease breaks the tie.
                    change=1 //because it would be defined as -1 if mvDifference is 0
                    inputmv = crease.mv
                    changedCrease = vertex.connectedCreases.filter(crease_ => crease_.mv != inputmv)[0] //change the first crease of the opposite mv
                    changedCrease.mv = inputmv
                    step3a(changedCrease, (changedCrease.vertices[0]==vertex? changedCrease.vertices[1] : changedCrease.vertices[0]))
                    // for(var i = 0; i<change; i++){
                    //     if(vertex.connectedCreases.filter(crease_ => crease_.mv !=inputmv)[i]==crease){
                    //         change +=1; //skip this one, but it doesn't count as a change
                    //         continue
                    //     }
                    //     changedCrease = vertex.connectedCreases.filter(crease_ => crease_.mv !=inputmv)[i]
                    //     //iterating through creases of the opposite mv
                    //     try{changedCrease.mv = inputmv=='red'? 'red':'blue'} catch{console.log(vertex, "failed crease change");return}
                    //     step3a(changedCrease, (changedCrease.vertices[0]==vertex? changedCrease.vertices[1] : changedCrease.vertices[0]))
                    // }
                } else if (mvDifference<0){
                    //if mv difference is negative (-4 -), convert valleys to mountain
                    for(var i = 0; i<change; i++){
                        if(vertex.connectedCreases.filter(crease => crease.mv =='blue')[i]==crease){
                            change +=1; //skip this one, but it doesn't count as a change
                            continue
                        }
                        changedCrease = vertex.connectedCreases.filter(crease => crease.mv =='blue')[i]
                        changedCrease.mv = 'red'
                        step3a(changedCrease, (changedCrease.vertices[0]==vertex? changedCrease.vertices[1] : changedCrease.vertices[0]))
                    }
                } else{
                    //if mv difference is positive (4+), convert mountains to valleys
                    for(var i = 0; i<change; i++){
                        if(vertex.connectedCreases.filter(crease => crease.mv =='red')[i]==crease){
                            change +=1; //because on this side, the change is negative
                            continue
                        }
                        changedCrease = vertex.connectedCreases.filter(crease => crease.mv =='red')[i]
                        changedCrease.mv = 'blue'
                        step3a(changedCrease, (changedCrease.vertices[0]==vertex? changedCrease.vertices[1] : changedCrease.vertices[0]))
                    }
                }
            }
            
            //display the generated cp
            function display(){
                paper.project.clear();
                //var bg = new paper.Path.Rectangle(0,0,400,400);
                //bg.fillColor = 'white';
                scale = 400/grid //ratio of pixels to grid units

                var gridlines = new paper.Group();
                for(i=1; i<grid; i++){
                    line1 = new paper.Path.Line(
                        new paper.Point(0,i*scale),
                        new paper.Point(400,i*scale)
                    )
                    line2 = new paper.Path.Line(
                        new paper.Point(i*scale,0),
                        new paper.Point(i*scale,400)
                    )
                    gridlines.addChild(line1);
                    gridlines.addChild(line2);
                }
                gridlines.strokeColor = '#CDCDCD'
                gridlines.strokeWidth = 1

                var creaselines = new paper.Group();
                for(i=0;i<creases.length;i++){
                    line = new paper.Path.Line(
                        new paper.Point(creases[i].vertices[0].x*scale,creases[i].vertices[0].y*-scale+400),
                        new paper.Point(creases[i].vertices[1].x*scale,creases[i].vertices[1].y*-scale+400)
                    )
                    line.strokeColor = creases[i].mv=='red'? "#EB5160": "#33A1FD" 
                    creaselines.addChild(line);
                }
                creaselines.strokeWidth = 2
                creaselines.opacity = 1

                invalids = findInvalids(vertices)
                for(i=0;i<invalids.length;i++){
                    new paper.Path.Circle({
                        center: new paper.Point(invalids[i].x*scale,invalids[i].y*-scale+400),
                        radius: scale/3,
                        opacity: 0.5,
                        fillColor: 'yellow'
                    })
                }

                mvErrors = findMvErrors(vertices)
                for(var i = 0; i< vertices.length; i++){
                    if([vertices[i].x,vertices[i].y].includes(0) || [vertices[i].x,vertices[i].y].includes(grid) ){continue}                    
                    if(vertices[i].smallAngles.length!=0 && 
                        vertices[i].smallAngles.filter(element => element[0].mv==element[1].mv).length/vertices[i].smallAngles.length > 0.5){
                        mvErrors.push(vertices[i])
                        continue
                    }
                } //this time, look for big little big lemma mv errors, just for display
                if (mvErrors.length == 0){console.log('DONE')} else{console.log("finished step 3")}
                for(i=0;i<mvErrors.length;i++){
                    new paper.Path.Circle({
                        center: new paper.Point(mvErrors[i].x*scale,mvErrors[i].y*-scale+400),
                        radius: scale/6,
                        opacity: 0.2,
                        fillColor: 'purple'
                    })
                }

                var border = new paper.Path.Rectangle(0,0,400,400);
                border.strokeColor = 'black';
                border.strokeWidth = 4;
            }

            //save as .cp
            function download(){
                //https://www.delftstack.com/howto/javascript/javascript-download/
                var cpFile = ""
                scale = 400/grid
                for(var i = 0; i<creases.length; i++){
                    //add each crease
                    cpFile += (creases[i].mv=='red'? '2 ':'3 ') + `${creases[i].vertices[0].x*scale-200} ${creases[i].vertices[0].y*-1*scale+200} ${creases[i].vertices[1].x*scale-200} ${creases[i].vertices[1].y*-1*scale+200}\n`
                }
                for(var i = 0; i<grid; i++){
                    //add the border
                    cpFile += `1 ${i*scale-200} -200 ${(i+1)*scale-200} -200\n`
                    cpFile += `1 ${i*scale-200} 200 ${(i+1)*scale-200} 200\n`
                    cpFile += `1 -200 ${i*scale-200} -200 ${(i+1)*scale-200}\n`
                    cpFile += `1 200 ${i*scale-200} 200 ${(i+1)*scale-200}\n`
                }
                var element = document.createElement('a');
                element.setAttribute('href','data:text/plain;charset=utf-8,' + encodeURIComponent(cpFile));
                element.setAttribute('download',"random_cp.cp")
                document.body.appendChild(element);
                element.click();
            }

            //auxilary functions
            function shuffle(array) {
                //https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
                let currentIndex = array.length,  randomIndex;
                // While there remain elements to shuffle...
                while (currentIndex != 0) {
                    // Pick a remaining element...
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    // And swap it with the current element.
                    [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
                }
                return array;
            }
            function sleep(milliseconds) {
                //https://www.sitepoint.com/delay-sleep-pause-wait/
                const date = Date.now();
                while(Date.now() < date + milliseconds){}
            }
        </script>
        <div>
            <button type = button onclick="generate()">Generate random cp</button>
            <button type = button onclick="step3()">Assign mountain/valley</button>
            <button type = button onclick="download()">Save as .cp file</button>
        </div> 
    </div>
</body>
</html>